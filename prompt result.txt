Here’s a single, ready-to-paste task brief for AWS Kiro. It’s written as an implementation spec + acceptance criteria so Kiro can scaffold the app end-to-end in line with the hackathon rules.

---

# Task: Build an AWS-native Meeting Scheduling Agent (Python + TypeScript) for Gmail & Outlook

## Objective

Create a production-deployable AI agent that manages meeting schedules: detects and resolves conflicts, prioritizes important meetings, proposes times, books/reschedules across calendars, and sends confirmations. It must run on AWS, use Amazon Bedrock with **Claude Sonnet 4.5**, leverage **Amazon Bedrock AgentCore** (≥1 primitive), and integrate with **both Gmail and Outlook**. Codebases in **Python** (agent/back end) and **TypeScript** (IaC + web).

## Constraints & Context

* Hackathon compliance: working agent, public repo, architecture diagram, 3-min demo, deployed URL, reproducible deployment.
* AWS Account: **058264503354**.
* Prefer region with Bedrock Claude Sonnet 4.5 and AgentCore availability (default to **us-east-1**; allow override via env).
* Only public/free data; no paid third-party APIs beyond AWS usage credits.
* Security: least-privilege IAM, secrets in AWS Secrets Manager, OAuth tokens stored encrypted, PII minimization.
* Multi-tenant-ready single-tenant MVP: scoped to one user by default, but design clean boundaries for multi-user later.

## High-Level Architecture (generate IaC + code)

* **Frontend (TypeScript):** Next.js (or Vite React) SPA for user auth, settings, priorities, and logs. Hosted on **S3 + CloudFront**.
* **Auth:** Amazon **Cognito** user pool (email+password/social optional). Store user↔OAuth account links.
* **API:** Amazon **API Gateway (HTTP)** → **AWS Lambda (Python)** handlers.
* **Agent runtime:** Python agent service using **Amazon Bedrock** (Claude Sonnet 4.5) + **AgentCore** primitives (see below).
* **State:** Amazon **DynamoDB** tables:

  * `Users`, `Connections` (OAuth), `AgentRuns`, `Meetings`, `Preferences`, `AuditLogs`.
* **Events/async:** Amazon **EventBridge** (periodic scans), **SQS** (tool calls), optional **Step Functions** (long workflows).
* **Secrets:** **AWS Secrets Manager** for Google/Microsoft OAuth client secrets, encrypt with KMS CMK.
* **Observability:** **CloudWatch Logs** + metrics/alarms; structured JSON logs with correlation IDs.
* **IaC:** **AWS CDK (TypeScript)** for all infrastructure; `cdk.json` with env for account 058264503354, region override.

## Gmail & Outlook Integrations (must)

* **Gmail + Google Calendar:** Google APIs with OAuth 2.0, minimal scopes:

  * `https://www.googleapis.com/auth/calendar` (rw), `gmail.send` (send), optionally `gmail.readonly` (only if needed).
* **Outlook + Microsoft 365 Calendar:** Microsoft Graph with OAuth 2.0:

  * `Calendars.ReadWrite`, `Mail.Send`, optionally `MailboxSettings.Read`.
* Token handling: PKCE where applicable; store refresh tokens encrypted; automatic refresh; per-user consent flows in UI.
* Normalize events (ISO 8601, timezone aware). Resolve timezones via user profile or calendar settings.

## Core Agent Design (must use Bedrock + AgentCore)

* **Reasoning LLM:** Amazon Bedrock **Claude Sonnet 4.5**.
* **AgentCore primitives (use at least one; prefer multiple):**

  * **Router/Planner**: decide which tool to call next (Gmail/Outlook/Calendar/Rescheduler/Notifier).
  * **Tool Invocation**: safe tool schema for each external API.
  * **Memory/State primitive**: lightweight preference store (priority contacts, working hours, meeting SLAs).
* **Tools (implement as schema-validated functions called by AgentCore):**

  1. `get_availability({range, attendees[], minDuration, constraints})`

     * Calls Google Calendar and/or Microsoft Graph; merges busy/free; returns windows sorted by fit score.
  2. `create_event({title, start, end, attendees[], location, conference, notes})`

     * Creates on the user’s primary calendar; adds video link (Google Meet or Teams).
  3. `reschedule_event({eventId, newSlots[], policy})`

     * Finds and books a new slot; sends notifications.
  4. `send_email({to[], subject, body, threadId?})`

     * Uses Gmail/Graph to confirm booking/cancellations with summaries.
  5. `extract_preferences({emailText|freeText})`

     * Updates user preferences (e.g., “avoid Fridays after 16:00”, “Mattias = high priority”).
  6. `prioritize_meeting({attendees[], subject, organizer, tags})`

     * Returns priority score based on rules and learned weights.
* **Policies/Reasoning guardrails:**

  * Never book outside user working hours unless `override=true`.
  * If conflicts among high-priority meetings, propose top 3 alternatives via email + UI.
  * Maintain human-in-the-loop option: “auto-book” off by default; “suggest only” default on.

## Features (MVP)

* Connect Gmail + Outlook via OAuth (both can be connected; app handles either or both).
* View unified availability and conflicts (UI timeline).
* One-click “Find time” for N participants across providers; propose top 3 slots.
* Auto-compose confirmation emails; optional auto-send.
* Rescheduler: detect conflicts or cancellations and rebook according to preferences.
* Preference center: working hours, buffer times, focus blocks, VIP list, default meeting length, meeting types.
* Audit log of agent decisions with short natural-language rationale.

## Prompts & Agent Behaviors (Kiro: generate prompt templates)

* **System prompt (summarized):**

  * You are a scheduling agent. Optimize for conflict-free calendars respecting user preferences and priority rules. Always use tools for reading/writing calendars and sending messages. Never hallucinate times. Explain choices succinctly in logs; keep emails concise and polite.
* **Few-shot examples:**

  * From a raw email request (“can we meet next week?”), call `get_availability`, rank slots, call `create_event`, then `send_email` with confirmation or propose times if `auto-book=false`.

## Data Model (DynamoDB)

* `Users(pk=userId)` → profile, timezone, createdAt.
* `Connections(pk=userId#provider)` → provider: google|microsoft, access/refresh tokens (encrypted), scopes, expiresAt.
* `Preferences(pk=userId)` → workingHours, buffers, vip[], defaultDurations, autoBook flag.
* `Meetings(pk=userId#eventId)` → providerEventId, start, end, attendees, status, priority.
* `AgentRuns(pk=runId)` → userId, inputs, chosenTools[], outputs, costEstimates.
* `AuditLogs(pk=userId, sk=ts)` → step logs for transparency.

## Frontend (TypeScript)

* Pages: `/connect`, `/dashboard`, `/preferences`, `/logs`.
* Components: Availability timeline, Conflict list, Connect buttons (Google/Microsoft), Test-run button.
* Call API via signed requests (Cognito ID token).

## Deployment & DevX

* **CDK stacks:** `CoreStack` (DynamoDB, Secrets, KMS, Cognito), `ApiStack` (Gateway, Lambdas, permissions), `WebStack` (S3/CloudFront), `EventsStack` (EventBridge rules), outputs for URLs and IDs.
* **Makefile / NPM scripts:** `npm run cdk:bootstrap`, `cdk deploy --all`.
* **CI/CD:** GitHub Actions: lint, test, cdk synth, deploy to test environment.
* **Config via env:** `REGION`, `BEDROCK_MODEL=claude-sonnet-4-5`, `GOOGLE_CLIENT_ID/SECRET`, `MS_CLIENT_ID/SECRET`.

## Security & Privacy

* OAuth tokens encrypted at rest; rotate client secrets via Secrets Manager.
* Strict scopes; no blanket `Mail.Read` unless absolutely required.
* PII redaction in logs; opt-in telemetry only.
* IAM least privilege; per-Lambda policies for only required services.

## Testing

* Unit tests (Python/TypeScript) for tools + planners.
* Integration tests hitting Google/Microsoft sandboxes or mocked fakes.
* E2E test that: connects one Gmail test user, proposes 3 slots with a Microsoft attendee, books, and emails confirmations.

## Deliverables (align to hackathon rules)

* **Public repo** with full source, setup docs, and **architecture diagram** (draw.io/mermaid).
* **Deployed URL** (CloudFront).
* **3-minute demo video** (YouTube/Vimeo) showing: connect → propose → book → reschedule → email.
* **README** includes: features, architecture, how to deploy (CDK), how to set Google/MS OAuth, env vars, model & region notes.
* Note “newly created” and list notable commits during the Submission Period.

## Acceptance Criteria (must pass)

1. Uses **Amazon Bedrock** with **Claude Sonnet 4.5** and **AgentCore** primitive(s) for planning/tooling.
2. Integrates **both Gmail and Outlook** via OAuth; can read availability and create/update events.
3. Resolves conflicts and proposes alternative times; can auto-send confirmations.
4. Reproducible deploy with **CDK**; environment comes up green with one command.
5. Public frontend loads from CloudFront; API endpoints functional.
6. Logs show AgentCore tool calls and short rationales.
7. Security: tokens in Secrets Manager/KMS; least-privilege IAM; no secrets in code.
8. Repo includes diagram, README, and demo video link; app URL shared.

## Nice-to-Have (if time permits)

* Video-conference auto-insertion (Meet/Teams).
* Focus-time protection windows.
* Basic learning of attendee time-zone preferences from history.
* Cost metrics (approx Bedrock tokens per run).

---

**Kiro, please:**

1. Scaffold the full stack (CDK + Lambda Python + React/Next TypeScript) per above.
2. Implement AgentCore planner + tools with schemas for calendar/email actions.
3. Generate secure OAuth flows (Google & Microsoft) and store tokens encrypted.
4. Provide seed scripts, env samples, and a mermaid architecture diagram in the README.
5. Default region `us-east-1`; make region configurable.
6. Output CloudFront URL, API base URL, and Cognito IDs after deploy.
